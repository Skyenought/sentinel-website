{
  "filename": "quick-start.md",
  "__html": "<h1>新手指南 (Sentinel Go)</h1>\n<p>欢迎来到 Sentinel 的世界！这篇新手指南将指引您快速入门 Sentinel Go。</p>\n<h2>引入 Sentinel 依赖</h2>\n<p>Sentinel Go 支持 go modules 的依赖，可以通过 <a href=\"https://github.com/alibaba/sentinel-golang/releases\">release 页面</a> 获取最新 release 版本，并通过 go mod 引用依赖：<code>require github.com/alibaba/sentinel-golang v1.0.4</code></p>\n<h2>定义资源</h2>\n<p>资源 (resource) 是 Sentinel 中的最核心概念之一，Sentinel 中所有的限流熔断机制都是基于资源生效的，不同资源的限流熔断规则互相隔离互不影响。</p>\n<p>在 Sentinel 中，用户可以灵活的定义资源埋点。资源可以是应用、接口、函数、甚至是一段代码。我们的流量治理机制都是为了保护这段资源运行如预期一样。</p>\n<p>用户通过 Sentinel api 包里面的接口可以把资源访问包起来，这一步称为“埋点”。每个埋点都有一个资源名称（resource），代表触发了这个资源的调用或访问。有了资源埋点之后，我们就可以针对资源埋点配置流量治理规则。即使没有配置任何规则，资源埋点仍然会产生 metric 统计。</p>\n<p>Sentinel API 接口可参考 <a href=\"./basic-api-usage.md\">使用文档</a> 及 <a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/api\">Go docs</a>。</p>\n<p>下面是一个示例代码，将<code>fmt.Println(&quot;hello world&quot;);</code> 作为资源（被保护的逻辑），用 API 包装起来。参考代码如下：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// We should initialize Sentinel first.</span>\nerr := sentinel.InitDefault()\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\tlog.Fatalf(<span class=\"hljs-string\">\"Unexpected error: %+v\"</span>, err)\n}\n\n<span class=\"hljs-comment\">// initialize sentinel rules</span>\ninitRules()\n\ne, b := sentinel.Entry(<span class=\"hljs-string\">\"some-test\"</span>, sentinel.WithTrafficType(base.Inbound))\n<span class=\"hljs-keyword\">if</span> b != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-comment\">// Blocked. We could get the block reason from the BlockError.</span>\n} <span class=\"hljs-keyword\">else</span> {\n\t<span class=\"hljs-comment\">// the resource was guarded.</span>\n        fmt.Println(<span class=\"hljs-string\">\"hello world\"</span>)\n\t<span class=\"hljs-comment\">// Be sure the entry is exited finally.</span>\n\te.Exit()\n}\n</code></pre>\n<h2>规则配置</h2>\n<p>针对埋点资源配置相应的规则，来达到流量治理的效果。目前 Sentinel Go 支持以下几种规则：</p>\n<ol>\n<li><a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/core/flow\">流控规则</a></li>\n<li><a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/core/isolation\">流量隔离规则（并发控制）</a></li>\n<li><a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/core/circuitbreaker\">熔断规则</a></li>\n<li><a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/core/system#Rule\">自适应过载保护规则</a></li>\n<li><a href=\"https://pkg.go.dev/github.com/alibaba/sentinel-golang/core/hotspot#Rule\">热点参数流控规则</a></li>\n</ol>\n<h3>基于QPS限流的完整的示例</h3>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">import</span> (\n\tsentinel <span class=\"hljs-string\">\"github.com/alibaba/sentinel-golang/api\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-comment\">// 务必先进行初始化</span>\n\terr := sentinel.InitDefault()\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\n\t<span class=\"hljs-comment\">// 配置一条限流规则</span>\n\t_, err = flow.LoadRules([]*flow.Rule{\n\t\t{\n\t\t\tResource:               <span class=\"hljs-string\">\"some-test\"</span>,\n\t\t\tThreshold:              <span class=\"hljs-number\">10</span>,\n\t\t\tTokenCalculateStrategy: flow.Direct,\n\t\t\tControlBehavior:        flow.Reject,\n\t\t},\n\t})\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(err)\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\n\tch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{})\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ {\n\t\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\t\t<span class=\"hljs-keyword\">for</span> {\n\t\t\t\t<span class=\"hljs-comment\">// 埋点逻辑，埋点资源名为 some-test</span>\n\t\t\t\te, b := sentinel.Entry(<span class=\"hljs-string\">\"some-test\"</span>)\n\t\t\t\t<span class=\"hljs-keyword\">if</span> b != <span class=\"hljs-literal\">nil</span> {\n\t\t\t\t\t<span class=\"hljs-comment\">// 请求被拒绝，在此处进行处理</span>\n\t\t\t\t\ttime.Sleep(time.Duration(rand.Uint64() % <span class=\"hljs-number\">10</span>) * time.Millisecond)\n\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\t<span class=\"hljs-comment\">// 请求允许通过，此处编写业务逻辑</span>\n\t\t\t\t\tfmt.Println(util.CurrentTimeMillis(), <span class=\"hljs-string\">\"Passed\"</span>)\n\t\t\t\t\ttime.Sleep(time.Duration(rand.Uint64() % <span class=\"hljs-number\">10</span>) * time.Millisecond)\n\n\t\t\t\t\t<span class=\"hljs-comment\">// 务必保证业务结束后调用 Exit</span>\n\t\t\t\t\te.Exit()\n\t\t\t\t}\n\n\t\t\t}\n\t\t}()\n\t}\n\t&lt;-ch\n}\n</code></pre>\n<p>Demo 运行后，可以看到控制台每秒稳定输出 &quot;Passed&quot; 10 次，和规则中预先设定的阈值是一样的。我们可以在 metric 日志里看到类似下面的输出：</p>\n<pre><code>1581516234000|2020-02-12 22:03:54|some-test|10|2068|10|0|5|0|0|0\n1581516235000|2020-02-12 22:03:55|some-test|10|2073|10|0|3|0|0|0\n1581516236000|2020-02-12 22:03:56|some-test|10|2058|10|0|5|0|0|0\n1581516237000|2020-02-12 22:03:57|some-test|10|2023|10|0|5|0|0|0\n1581516238000|2020-02-12 22:03:58|some-test|10|2046|10|0|5|0|0|0\n</code></pre>\n<p>其中 <code>some-test</code> 这一列代表埋点资源名，后面的数字依次代表该一秒内的通过数（pass）、拒绝数（block）、完成数（complete）、错误数目（error）、平均响应时长（rt）。详细信息可以参考 <a href=\"https://github.com/alibaba/sentinel-golang/wiki/%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7#%E7%A7%92%E7%BA%A7%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97\">监控日志文档</a>。</p>\n<p>在生产环境中，建议对接 <a href=\"./dynamic-data-source-usage.md\">动态数据源</a> 以便动态管理规则，而不是通过硬编码方式配置规则。</p>\n"
}